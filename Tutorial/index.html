<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Chipmunk Game Dynamics Documentation</title>
		<link rel="stylesheet" type="text/css" href="stylesheet.css" />
	</head>
	<body>
<script language="javascript">
    function toggleDiv(divid){
        if(document.getElementById(divid).style.display == 'none'){
            document.getElementById(divid).style.display = 'block';
        }else{
            document.getElementById(divid).style.display = 'none';
        }
    }
    
    function toggleExample(divid, name){
        toggleDiv(divid);
        var div = document.getElementById(divid);
        var i = div.innerHTML;
        
        if(div.innerHTML == ""){
            div.innerHTML = "Loading ..."
            
            var xmlhttp = new XMLHttpRequest();
            xmlhttp.onreadystatechange = function(){
                if(xmlhttp.readyState == 4){
                    div.innerHTML = xmlhttp.responseText;
                }
            }
            
            xmlhttp.open("GET", name, true);
            xmlhttp.send();
        }
    }
</script>



<img src="images/logo1_med.png" alt="" /> <a href="http://howlingmoonsoftware.com"><img src="images/hms_logo.png" style="float:right;" alt="" /></a>

<h1>Chipmunk Tile Tutorial:</h1>

<img src="images/final.png" width="320" style="float:right;"/>

<p>
This tutorial shows you how you can use Chipmunk in a top down game. It covers an easy way to set up controls and an easy way to generate the collision shape of a tilemap.
</p>

<p>
<A href="http://www.raywenderlich.com/1163/how-to-make-a-tile-based-game-with-cocos2d">Ray Wenderlich's How to Make a Tile-Based Game with Cocos2d</A> is a starting point for this tutorial. In this tutorial, we build off that example by adding physics, smooth motion between tiles (the player doesn't snap to a tile), and collisions. If you find this tutorial moves a little too quickly, start with that one first. This example has been updated for Cocos2D 2.1.
</p>


<p>You should know the basics about Chipmunk such as how to create spaces, bodies and shapes. You might want to read up on some of the documentation or the Chipmunk Basics tutorial on the <a href="http://chipmunk-physics.net/documentation.php">documentation page</a>.</p>

<p><em>TODO: I either haven't made the Chipmunk Basics tutorial yet or forgot to remove this reminder to myself. Please send me an email if I've forgotten. ;)</em></p>

<p><strong>You can download this tutorial and all the project files from the <a href="https://github.com/andykorth/ChipmunkTileDemo">GitHub page</a>. These are ready to build!</strong></p>

<h2>What Do You Need to Know First?</h2>

<p>This tutorial assumes you have some prior experience with Cocos2D development. It doesn't go into how Cocos2D itself works, although the project is pretty simple. We also assume you know how to use Tiled and a few other things covered in <A href="http://www.raywenderlich.com/1163/how-to-make-a-tile-based-game-with-cocos2d">this tutorial</A>.</p>

<h2>What is Chipmunk?</h2>

<p>Chipmunk is a 2D rigid body physics library distributed under the MIT license. It is intended to be fast, portable, numerically stable, and easy to use. For this reason it's been used in hundreds of games on just about every system you could name. This includes a lot of successful games such as Waking Mars, Night Sky, Zombie Smash, Feed Me Oil and many others. I've put thousands of hours of work over many years to make Chipmunk what it is today. Check out Chipmunk's <a href="http://chipmunk-physics.net">website</a> for more information.</p>

<h2>What is Objective-Chipmunk and Chipmunk Pro?</h2>

<p>Objective-Chipmunk is an Objective-C wrapper for the Chipmunk Physics Library distributed as part of Chipmunk Pro and Chipmunk Indie. While Chipmunk's C API is pretty easy to use, the Objective-C API is even better. The primary advantages of a native Objective-C API include integrating with the Cocoa memory management model (including ARC) and the Chipmunk Object protocol. The Chipmunk Object protocol unifies the basic Chipmunk types as well as making it easy to create custom composite collections of the basic types. Additionally, the wrapper adds many convenience methods for doing common setup tasks as well as helper methods that integrate it with the rest of the Cocoa Touch API. The wrapper tries to do things the Objective-C way, adding useful method variations where it makes sense to do so.</p>

<p>You can find out more information on <a href="http://chipmunk-physics.net">Chipmunk's website</a>. While Objective-Chipmunk is not free like Chipmunk is, the enhanced API will almost certainly save you time and money. You'll also be helping to support further Chipmunk development!</p>

<h1>Let's get started!</h1>

<p>At the end of Ray's tutorial, you can load a map created in Tiled. Your player can move around, but he snaps to individual tiles, so the game doesn't feel very smooth. First, take a look at the interface for our class. It hasn't changed much from the previous tutorial.</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; "><span style="color:#236e25;">// HelloWorldLayer<br />
</span><span style="color:#881350;">@interface</span> HelloWorldLayer : CCLayer<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Inside the HelloWorld class declaration<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;CCTMXTiledMap *_tileMap;<br />
&nbsp;&nbsp;&nbsp;&nbsp;CCTMXLayer *_background;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;CCTMXLayer *_meta;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;CCPhysicsSprite *_player;<br />
}</div>

<p>
The CCTMX classes are used for reading the tile map. Remember, the <code>_background</code> layer contains the tile artwork, such as the desert, the cacti, the roads, and the walls. The  <code>_meta</code> layer contains <A HREF="http://www.raywenderlich.com/1186/collisions-and-collectables-how-to-make-a-tile-based-game-with-cocos2d-part-2">hand-painted collision information</A>. Of course, there are other approaches that might work better in your game, but we're going to roll with this approach.
</p>
<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">CCPhysicsSprite *_player</div>
<p>CCPhysicsSprite is a new class in Cocos2d 2.1. Developers often struggle with making their graphics line up with a physics simulation, and this class is very helpful in that regard. Each time the physics simulation updates the position or rotation of an object in the world, the sprite is updated to reflect that. It is a subclass of CCSprite; if you are familiar with that class, the use is similar.</p>

<h2>Starting with init:</h2>

<p>I'll move quickly through this review:</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; "><span style="color:#236e25;">// on &quot;init&quot; you need to initialize your instance<br />
</span>-(<span style="color:#881350;">id</span>) <span style="color:#6c0540;">init</span><br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// always call &quot;super&quot; init<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Apple recommends to re-assign &quot;self&quot; with the &quot;super&quot; return value<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">if</span>( (<span style="color:#881350;">self</span>=[<span style="color:#881350;">super</span> <span style="color:#6c0540;">init</span>])) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Setup the space. We won't set a gravity vector since this is top-down<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;space = [[ChipmunkSpace <span style="color:#ff0000;">alloc</span>] <span style="color:#6c0540;">init</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isTouching = false;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">self</span>.touchEnabled = <span style="color:#881350;">YES</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tileMap = [CCTMXTiledMap <span style="color:#6c0540;">tiledMapWithTMXFile:</span><span style="color:#760f15;">@&quot;TileMap.tmx&quot;</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_background = [_tileMap <span style="color:#6c0540;">layerNamed:</span><span style="color:#760f15;">@&quot;Background&quot;</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">addChild:</span>_tileMap <span style="color:#6c0540;">z:</span>-<span style="color:#0000ff;">1</span>];<br />
</div>

<p>Basic setup of this Cocos2d layer includes stuff like enabling touches, loading the tilemap, and adding it to the layer. Confused? Check <A href="http://www.raywenderlich.com/1163/how-to-make-a-tile-based-game-with-cocos2d">this tutorial</A>.
</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCTMXObjectGroup *objects = [_tileMap <span style="color:#6c0540;">objectGroupNamed:</span><span style="color:#760f15;">@&quot;Objects&quot;</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#400080;">NSAssert</span>(objects != <span style="color:#881350;">nil</span>, <span style="color:#760f15;">@&quot;'Objects' object group not found&quot;</span>);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#400080;">NSMutableDictionary</span> *spawnPoint = [objects <span style="color:#6c0540;">objectNamed:</span><span style="color:#760f15;">@&quot;SpawnPoint&quot;</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#400080;">NSAssert</span>(spawnPoint != <span style="color:#881350;">nil</span>, <span style="color:#760f15;">@&quot;SpawnPoint object not found&quot;</span>);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">int</span> x = [[spawnPoint <span style="color:#6c0540;">valueForKey:</span><span style="color:#760f15;">@&quot;x&quot;</span>] <span style="color:#6c0540;">intValue</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">int</span> y = [[spawnPoint <span style="color:#6c0540;">valueForKey:</span><span style="color:#760f15;">@&quot;y&quot;</span>] <span style="color:#6c0540;">intValue</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_meta = [_tileMap <span style="color:#6c0540;">layerNamed:</span><span style="color:#760f15;">@&quot;Meta&quot;</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_meta.visible = <span style="color:#881350;">NO</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
</div>

<p>
Tiled supports annotating the map with specific information. So we've done so with a "SpawnPoint" object. We pull out the x and y values for use later. Meta is the name of a layer that controls collision information.  Tiles painted in this layer will be solid for our collisions.
</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Add a CCPhysicsDebugNode to draw the space.<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCPhysicsDebugNode *debugNode = [CCPhysicsDebugNode <span style="color:#6c0540;">debugNodeForChipmunkSpace:</span>space];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">addChild:</span>debugNode];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
</div>

<p>
One nice thing about working with Chipmunk in Cocos2d is easy debugging of shapes with <code>CCPhysicsDebugNode</code>. This node draws all the objects in your physics space to the scene. So if you've got graphics that don't line up with your simulation, or you've forgotten to place a wall, you can easily determine what is going on. These two lines add that debug drawing.
</p>
<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// We've broken out the creation of the player and terrain into separate methods<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">createPlayer:</span>y <span style="color:#6c0540;">x:</span>x];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">createTerrainGeometry</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// add some crates, it's not a video game without crates!<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">for</span>(<span style="color:#881350;">int</span> i=<span style="color:#0000ff;">0</span>; i&lt;<span style="color:#0000ff;">16</span>; i++){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">float</span> dist = <span style="color:#0000ff;">50.0f</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">makeBoxAtX:</span> x + (i % <span style="color:#0000ff;">4</span>) * dist + <span style="color:#0000ff;">200</span> <span style="color:#6c0540;">y:</span> y + ( i / <span style="color:#0000ff;">4</span>) * dist - <span style="color:#0000ff;">200</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">setViewpointCenter:</span>_player.position];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// schedule updates, which also steps the physics space:<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">scheduleUpdate</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
</div>

<p>
And we do three things here. We create the player, then we create the terrain geometry, then add some boxes. After that there's a little cleanup by making sure the view starts centered on the player and that the Cocos2d update method is scheduled to be called. Let's look at each of these individually.
</p>

<h2>Creating a Top Down Player using Chipmunk:</h2>
<p>
Our goal is to have a player that smoothly moves through the world, slides along walls without gettings stuck, and can push around blocks. From the perspective of controls, we also want them to quickly and smoothly start and stop moving. So let's get to the code!
</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">- (<span style="color:#881350;">void</span>)<span style="color:#6c0540;">createPlayer:</span>(<span style="color:#881350;">int</span>)y <span style="color:#6c0540;">x:</span>(<span style="color:#881350;">int</span>)x<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// set up the player body and shape<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">float</span> playerMass = <span style="color:#0000ff;">1.0f</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">float</span> playerRadius = <span style="color:#0000ff;">13.0f</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;playerBody = [space <span style="color:#6c0540;">add:</span>[ChipmunkBody <span style="color:#6c0540;">bodyWithMass:</span>playerMass <span style="color:#6c0540;">andMoment:</span>INFINITY]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;_player = [CCPhysicsSprite <span style="color:#6c0540;">spriteWithFile:</span><span style="color:#760f15;">@&quot;chipmunkMan.png&quot;</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;_player.chipmunkBody = playerBody;<br />
&nbsp;&nbsp;&nbsp;&nbsp;playerBody.pos = <span style="color:#003369;">ccp</span>(x,y);<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">addChild:</span>_player];</div>

<p>
First, we set up the ChipmunkBody for the player. We create it with a mass of 1.0 and an infinite moment of inertia. That infinite moment will prevent the player from rotating. A player that could rotate would start spinning when you slide against walls. And when a rotating player came in contact with something they could push, like a box, the friction between the player and the box would cause it to move in a weird way.
</p>
<p>
_player is our CCSprite- in this case, a CCPhysicsSprite. CCPhysicsSprite is a subclass of CCSprite that ties the sprite to a physics body. When the physics body moves around, the sprite also moves- in fact what happens behind the scene is that the sprite just accesses the physics body for position, rotation, etc. We set the body of the physics sprite to the ChipmunkBody we just made, and then set the position to (x, y), the position of the spawn point we passed in as an argument. 
</p>
<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;ChipmunkShape *playerShape = [space <span style="color:#6c0540;">add:</span>[ChipmunkCircleShape <span style="color:#6c0540;">circleWithBody:</span>playerBody <span style="color:#6c0540;">radius:</span>playerRadius <span style="color:#6c0540;">offset:</span>cpvzero]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;playerShape.friction = <span style="color:#0000ff;">0.1</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;</div>
<p>
Circles make good representations of just about any character. Before you think you need a more complicated polygon, please start with a circle- there are several advantages. Most importantly, circles have no edges or corners that get caught on other geometry. Since they have a constant radius, you are always sure of the size of the player and what they can fit into. We set a little friction, mostly to dictate how our player interacts with other objects.
</p>
<p>
Although we're thinking of this as a top-down game, the friction component does not represent the player's friction with the ground. There isn't a 'ground' object in our game- you're just always in contact with the ground. We'll get to this more later.
</p>


<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;targetPointBody = [[ChipmunkBody <span style="color:#ff0000;">alloc</span>] <span style="color:#6c0540;">initStaticBody</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;targetPointBody.pos = <span style="color:#003369;">ccp</span>(x,y); <span style="color:#236e25;">// make the player's target destination start at the same place the player.<br />
</span></div>
<p>
We use a static body as a control body. This control body represents the target destination of the player. Because this is an iOS demo, we decided to go with a control scheme where you tap a point on the screen, and the character moves towards it. If you hold down your finger, the player keeps moving in that direction. So when it's time to handle input, it's very simple, we just set the position of the control body to the touch.
</p>
<p>
But how is this static body used to control the motion of the player?
</p>
<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;ChipmunkPivotJoint* joint = [space <span style="color:#6c0540;">add:</span>[ChipmunkPivotJoint <span style="color:#6c0540;">pivotJointWithBodyA:</span>targetPointBody <span style="color:#6c0540;">bodyB:</span>playerBody <span style="color:#6c0540;">anchr1:</span>cpvzero <span style="color:#6c0540;">anchr2:</span>cpvzero]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;joint.maxBias = <span style="color:#0000ff;">200.0f</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;joint.maxForce = <span style="color:#0000ff;">3000.0f</span>;</div>

<p>
In short, this joint controls the motion of the player by tying together the static <strong>targetPointBody</strong> and the <strong>playerBody</strong>. MaxForce controls the player's pushing power, and maxBias controls the correction speed (ie: the speed the player moves across the ground).
</p>

<div style="display:block; margin:20px;"><a class="HideShow" href="javascript:;" onmousedown="toggleExample('HowDoesItWork', 'examples/Hello%20Chipmunk.html');">I want to know the details!</a><div id="HowDoesItWork" style="display: none;">
<p>
Joints control the motion of the player. Our pivot joint pulls the player towards the targetPointBody. Because that's a static body, only the player moves (unless we explicitly set the position of targetPointBody). It sort of acts like a spring or a rubber band, with the player constantly trying to move towards the control point, but it's simpler than that. There's no springy-ness to the motion- we have just two values to tweak:
</p>
<p>
<strong>maxBias</strong> controls the maximum speed at which a joint can be corrected. So if our playerBody is far away from the targetPointBody, there's a limit to how far per second the player is pulled towards the targetPointBody. So this is really a max speed for the player's motion across the world. This works great for our game since we want the player to move at the same speed if he's going horizontally, vertically, or diagonally.
</p>
<p>
<strong>maxForce</strong> controls the maximum force the joint will apply to correct the positions. If you've ever seen things <A href="http://www.youtube.com/watch?v=vfl33Tn0pYc">explode in video games</A> (I'm sure you've seen a thousand of them), you'll know why you want to set maximum forces. Often these glitches are a result of something exerting huuuuuuuge amounts of force trying to get something to move. By adjusting this maxForce value, you control things like how many boxes we're able to push. 
</p>
<p>
<em>But why not just set the position of the player body when I want to move him?</em>  Good question! Think of setting the position of a body to be "teleporting" that object somewhere. You aren't telling the physics engine how it got there. Chipmunk doesn't know how much force should be applied if it does hit an object along the way. And you may have teleported something right into a wall. Chipmunk will still resolve that collision and fix it, but you'll see the object you've teleported move into the wall more than you would have otherwise. 
</p>
<p>
<em>Well then, how about just setting the velocity each frame?</em>  This is an improvement! By setting the velocity, the physics engine solver can set the position and does a better job of ensuring the object doesn't move into another piece of geometry. When you have a collision, the engine knows the speed of the colliding objects and can calculate how they get knocked back.</p>
<p>
Follow along with me. Place our hand on a wall... then apply a velocity to it- into the wall. You can't. You can apply a force. (Hopefully your personal maxForce is not enough to move your wall.. otherwise, I'm sorry for broke your wall). So you could apply forces instead. That works great for things like cannons, but continual forces can be awkward when you've got a character that you want to maintain moving at a constant speed.
</p>
<p>
And finally, by using a control point and a joint, we don't have to worry calculating if we're close to our destination point and adjusting the force or velocity. We also get to slide around edges of walls. Pretty slick for just a few lines of code!
</p>
<p>For even more info, check out <A href="http://chipmunk-physics.net/release/ChipmunkLatest-Docs/#cpConstraint-ErrorCorrection">this page in the Chipmunk Manual</A>.
</div></div>


<h2>Creating the terrain geometry using Chipmunk's Autogeometry features:</h2>
<p>
Let's start with a brief rundown on how the you can write different samplers for Chipmunk's auto-geometry features. Samplers are used by Chipmunk to create geometry by looking at specific points; you could think of it as a density function. A sampling function takes a point (a cpVect) as an argument, and returns the density at that location. Image samplers are an easy example of a sampling function. The sampling function would just look at the image at (x, y) and return the color or alpha of the image at that pixel.
</p>
<p>
Sampling functions could work anyway you imagine. Sampling images is common, but they could sample a noise function, or a fractal pattern, or anything you could imagine. Here we're going to sample the tilemap. 
</p>
<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">- (<span style="color:#881350;">void</span>)<span style="color:#6c0540;">createTerrainGeometry</span><br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">int</span> tileCountW = _meta.layerSize.width;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">int</span> tileCountH = _meta.layerSize.height;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cpBB sampleRect = <span style="color:#003369;">cpBBNew</span>(<span style="color:#0000ff;">-0.5</span>, <span style="color:#0000ff;">-0.5</span>, tileCountW + <span style="color:#0000ff;">0.5</span>, tileCountH + <span style="color:#0000ff;">0.5</span>);</div>

<p>
We'll be using the <strong>cpBB sampleRect</strong> later to tell the autogeometry the range that it should look at. It goes from approximately (0, 0) to (tileCountW, tileCountH)... the width and height of the tilemap. I know you already want to know what's up with the halfs- the 0.5f. There are two things we're doing here:
</p>
<p>
First, we're sampling from the center of tiles. (0, 0) is the top left corner of our top left tile. (1, 0) is the  top left corner of the next tile to the right. We want our geometry centered at the center of the tile- not centered over the corner of tiles. This way the collision edges line up with the edges of the tiles. So, (0.5, 0.5) is the center of the top-left tile.
</p>
<p>
<em>But we start at (-0.5, -0.5)!</em> Yup. If we started at 0.5, there'd be half a tile gap in our geometry around the edge of the screen. Even if a wall went all the way to the edge of the screen, we could push a narrow box between the wall and the edge. So we want to sample and extra tile out, and then we'll clamp the data in the next step.
</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Create a sampler using a block that samples the tilemap in tile coordinates.<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;ChipmunkBlockSampler *sampler = [[ChipmunkBlockSampler <span style="color:#ff0000;">alloc</span>] <span style="color:#6c0540;">initWithBlock:</span>^(cpVect point){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>
<p>
ChipmunkBlockSampler is a convenient way of using an <A href="http://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/bxGettingStarted.html#//apple_ref/doc/uid/TP40007502-CH7-SW1">Objective-C block</A>, as noted by the ^. The block has an argument cpVect point and should return a float. 
</p>
<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Clamp the point so that samples outside the tilemap bounds will sample the edges.<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;point = <span style="color:#003369;">cpBBClampVect</span>(<span style="color:#003369;">cpBBNew</span>(<span style="color:#0000ff;">0.5</span>, <span style="color:#0000ff;">0.5</span>, tileCountW - <span style="color:#0000ff;">0.5</span>, tileCountH - <span style="color:#0000ff;">0.5</span>), point);</div>
<p>
First, we clamp the point vector to deal with the border of the map. In the event the the sampler asks for coordinates outside of the tilemap, we want a reasonable response. Clamping ranges outside of the bounds of the tilemap onto the edge is reasonable. We could also just return 1.0 for anything outside of the bounds, or we could wrap the coordinates. 
</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// The samples will always be at tile centers.<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// So we just need to truncate to an integer to convert to tile coordinates.<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">int</span> x = point.x;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">int</span> y = point.y;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Flip the y-coord (Cocos2D tilemap coords are flipped this way)<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = tileCountH - <span style="color:#0000ff;">1</span> - y;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Look up the tile to see if we set a Collidable property in the Tileset meta layer<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#400080;">NSDictionary</span> *properties = [_tileMap <span style="color:#6c0540;">propertiesForGID:</span>[_meta <span style="color:#6c0540;">tileGIDAt:</span><span style="color:#003369;">ccp</span>(x, y)]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">BOOL</span> collidable = [[properties <span style="color:#6c0540;">valueForKey:</span><span style="color:#760f15;">@&quot;Collidable&quot;</span>] <span style="color:#6c0540;">isEqualToString:</span><span style="color:#760f15;">@&quot;True&quot;</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// If the tile is collidable, return a density of 1.0 (meaning solid)<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Otherwise return a density of 0.0 meaning completely open.<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">return</span><span style="color:#003369;"> </span>(collidable ? <span style="color:#0000ff;">1.0f</span> : <span style="color:#0000ff;">0.0f</span>);<br />
&nbsp;&nbsp;&nbsp;&nbsp;}];<br />
</div>

<p>
This is the rest of the sampling function! We truncate our sampling points; the tile that has a center at (3.5f, 2.5f) is stored in our tilemap just as (3, 2). So after we flip things upside down (no one ever agrees if y=0 is on the top or bottom...) we look up the tile in the _meta layer to see if we have marked it "Collidable". This is how we painted our tiles in the Tiled editor. Finally, if it's collidable, we return 1.0, otherwise we return 0.0.
</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;ChipmunkPolylineSet * polylines = [sampler <span style="color:#6c0540;">march:</span>sampleRect <span style="color:#6c0540;">xSamples:</span>tileCountH + <span style="color:#0000ff;">2</span> <span style="color:#6c0540;">ySamples:</span>tileCountH + <span style="color:#0000ff;">2</span> <span style="color:#6c0540;">hard:</span>TRUE];<br />
</div>

<p>
Here's where the magic happens! The <strong>march</strong> function on the sampler we created takes the sampleRect as an argument. It will run it's algorithm on each tile in the sampleRect. It will do xSamples across the x-axis, and because the sampleRect is tileCountW + 2 tiles wide (remember we added one on the left and right edge), each sample will fall right in the center of each tile. Same for the y-axis. 
<strong>TODO: Add a diagram of this!</strong>
</p>
<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;cpFloat tileW = _tileMap.tileSize.width;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cpFloat tileH = _tileMap.tileSize.height;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">for</span>(ChipmunkPolyline * line in polylines){</div>
<p>
And our work is almost over. Our march function returns a ChipmunkPolylineSet. So we loop over each polyline in that set.
</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChipmunkPolyline * simplified = [line <span style="color:#6c0540;">simplifyCurves:</span><span style="color:#0000ff;">0.0f</span>];<br />
&nbsp;</div>
<p>
Then we use the simplifyCurves method to remove redundant points. Since we supply 0.0f as an argument, there's no fuzz factor. The lines are removed losslessly, with no changes in geometry. Because the initial polyline contains every segment created by the marching squares algorithm, we've got a lot of short segments that this will collapse into longer ones.
</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">for</span>(<span style="color:#881350;">int</span> i=<span style="color:#0000ff;">0</span>; i&lt;simplified.count-<span style="color:#0000ff;">1</span>; i++){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// The sampler coordinates were in tile coordinates.<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Convert them to pixel coordinates by multiplying by the tile size.<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpVect a = <span style="color:#003369;">cpvmult</span>(simplified.verts[ &nbsp;<span style="color:#6c0540;">i</span>], tileW);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpVect b = <span style="color:#003369;">cpvmult</span>(simplified.verts[i+<span style="color:#0000ff;">1</span>], tileH);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Add the shape and set some properties.<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChipmunkShape *seg = [space <span style="color:#6c0540;">add:</span>[ChipmunkSegmentShape <span style="color:#6c0540;">segmentWithBody:</span>space.staticBody <span style="color:#6c0540;">from:</span>a <span style="color:#6c0540;">to:</span>b <span style="color:#6c0540;">radius:</span><span style="color:#0000ff;">1.0f</span>]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seg.friction = <span style="color:#0000ff;">1.0</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
</div>

<p>
Now we loop over each segment in our simplified line loop, and convert it's coordinates into pixel coordinates. Then we create and add a ChipmunkSegment just like normal.
</p>


<h2>Add some boxes!</h2>

<p>Well, the hard part is over. Now we want to have something to push around. </p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; "><br />
- (ChipmunkBody*)<span style="color:#6c0540;">makeBoxAtX:</span>(<span style="color:#881350;">int</span>)x <span style="color:#6c0540;">y:</span>(<span style="color:#881350;">int</span>)y<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">float</span> mass = <span style="color:#0000ff;">0.3f</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">float</span> size = <span style="color:#0000ff;">27.0f</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;ChipmunkBody* body = [ChipmunkBody <span style="color:#6c0540;">bodyWithMass:</span>mass <span style="color:#6c0540;">andMoment:</span><span style="color:#003369;">cpMomentForBox</span>(mass, size, size)];<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;CCPhysicsSprite * boxSprite = [CCPhysicsSprite <span style="color:#6c0540;">spriteWithFile:</span><span style="color:#760f15;">@&quot;crate.png&quot;</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;boxSprite.chipmunkBody = body;<br />
&nbsp;&nbsp;&nbsp;&nbsp;boxSprite.position = <span style="color:#003369;">cpv</span>(x,y);<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;ChipmunkShape* boxShape = [ChipmunkPolyShape <span style="color:#6c0540;">boxWithBody:</span>body <span style="color:#6c0540;">width:</span> size <span style="color:#6c0540;">height:</span> size];<br />
&nbsp;&nbsp;&nbsp;&nbsp;boxShape.friction = <span style="color:#0000ff;">1.0f</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;[space <span style="color:#6c0540;">add:</span>boxShape];<br />
&nbsp;&nbsp;&nbsp;&nbsp;[space <span style="color:#6c0540;">add:</span>body];<br />
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">addChild:</span>boxSprite];<br />
</div>

<p>
Much of this is similar to how we created our player. We create a ChipmunkBody with the mass and size that we've picked out. We've got our convenient CCPhysicsSprite created. [ChipmunkPolyShape boxWithBody] is a shortcut to creating a box shape- a rectangular polygon. Then we add the shape and body to the to the space, and add the sprite to the layer.
</p>
<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;ChipmunkPivotJoint* pj = [space <span style="color:#6c0540;">add:</span> [ChipmunkPivotJoint <span style="color:#6c0540;">pivotJointWithBodyA:</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[space <span style="color:#6c0540;">staticBody</span>] <span style="color:#6c0540;">bodyB:</span>body <span style="color:#6c0540;">anchr1:</span>cpvzero <span style="color:#6c0540;">anchr2:</span>cpvzero]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;pj.maxForce = <span style="color:#0000ff;">1000.0f</span>; <span style="color:#236e25;">// emulate linear friction<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;pj.maxBias = <span style="color:#0000ff;">0</span>; <span style="color:#236e25;">// disable joint correction, don't pull it towards the anchor.<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Then use a gear to fake an angular friction (slow rotating boxes)<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;ChipmunkGearJoint* gj = [space <span style="color:#6c0540;">add:</span> [ChipmunkGearJoint <span style="color:#6c0540;">gearJointWithBodyA:</span>[space <span style="color:#6c0540;">staticBody</span>] <span style="color:#6c0540;">bodyB:</span>body <span style="color:#6c0540;">phase:</span><span style="color:#0000ff;">0.0f</span> <span style="color:#6c0540;">ratio:</span><span style="color:#0000ff;">1.0f</span>]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;gj.maxForce = <span style="color:#0000ff;">5000.0f</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;gj.maxBias = <span style="color:#0000ff;">0.0f</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">return</span> body;<br />
}<br />
</div>
<p>
Since this is a top-down game, we need to fake friction with the "ground" that things are standing on. We do this by creating two joints, one for linear friction and one for angular friction.
</p>
<p>
Linear friction is basically what we want to simulate to make something that is moving in a straight line slow down. The maxForce basically controls how quickly the object slows down- how much force can be applied each frame until it reaches the same speed as the static body (which is zero). We set the maxBias, which we discussed briefly above. Recall that maxBias limits the maximum speed at which a joint can be corrected. For this joint, "correcting the joint" at a certain maxBias means how quickly Chipmunk will try to make the anchors move back to overlap. Because we've set the maxBias to zero, it doesn't try to correct these positions, and it ignores the fact that you are stretching the joint out. It only operates on the velocity.
</p>
<p>
Angular friction is simulated to make a rotating object slowly stop rotating. Gear joints govern rotation, so we've chosen to use that. Here we set the maxBias and maxForce just like above.
</p>
<h2>Conclusion</h2>
<p>
That's it! We've covered a few advanced topics, like good ways to deal with friction in a top down game, and how to use Chipmunk's Autogeometry code. If you have questions, comments, or suggestions regarding this tutorial, feel free to email us at admin at howlingmoonsoftware.com. Also consider checking out the <A href="chipmunk-physics.net/forum/">Chipmunk Forum</A>.
</p>

	</body>
</html>
