<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Chipmunk Game Dynamics Documentation</title>
		<link rel="stylesheet" type="text/css" href="stylesheet.css" />
	</head>
	<body>

<img src="images/logo1_med.png" alt="" /> <a href="http://howlingmoonsoftware.com"><img src="images/hms_logo.png" style="float:right;" alt="" /></a>

<h1>Chipmunk Tile Tutorial:</h1>

<img src="images/final.png" width="320" style="float:right;"/>

<p>
This tutorial shows you how you can use Chipmunk in a top down game. It covers an easy way to set up controls and an easy way to generate the collision shape of a tilemap.
</p>

<p>
<A href="http://www.raywenderlich.com/1163/how-to-make-a-tile-based-game-with-cocos2d">Ray Wenderlich's How to Make a Tile-Based Game with Cocos2d</A> is a starting point for this tutorial. In this tutorial, we build off that example by adding physics, smooth motion between tiles (the player doesn't snap to a tile), and collisions. If you find this tutorial moves a little too quickly, start with that one first. This example has been updated for Cocos2D 2.1.
</p>


<p>You should know the basics about Chipmunk such as how to create spaces, bodies and shapes. You might want to read up on some of the documentation or the Chipmunk Basics tutorial on the <a href="http://chipmunk-physics.net/documentation.php">documentation page</a>.</p>

<p><em>TODO: I either haven't made the Chipmunk Basics tutorial yet or forgot to remove this reminder to myself. Please send me an email if I've forgotten. ;)</em></p>

<p><strong>You can download this tutorial and all the project files from the <a href="https://github.com/andykorth/ChipmunkTileDemo">GitHub page</a>. These are ready to build!</strong></p>

<h2>What Do You Need to Know First?</h2>

<p>This tutorial assumes you have some prior experience with Cocos2D development. It doesn't go into how Cocos2D itself works, although the project is pretty simple. We also assume you know how to use Tiled and a few other things covered in <A href="http://www.raywenderlich.com/1163/how-to-make-a-tile-based-game-with-cocos2d">this tutorial</A>.</p>

<h2>What is Chipmunk?</h2>

<p>Chipmunk is a 2D rigid body physics library distributed under the MIT license. It is intended to be fast, portable, numerically stable, and easy to use. For this reason it's been used in hundreds of games on just about every system you could name. This includes a lot of successful games such as Waking Mars, Night Sky, Zombie Smash, Feed Me Oil and many others. I've put thousands of hours of work over many years to make Chipmunk what it is today. Check out Chipmunk's <a href="http://chipmunk-physics.net">website</a> for more information.</p>

<h2>What is Objective-Chipmunk and Chipmunk Pro?</h2>

<p>Objective-Chipmunk is an Objective-C wrapper for the Chipmunk Physics Library distributed as part of Chipmunk Pro and Chipmunk Indie. While Chipmunk's C API is pretty easy to use, the Objective-C API is even better. The primary advantages of a native Objective-C API include integrating with the Cocoa memory management model (including ARC) and the Chipmunk Object protocol. The Chipmunk Object protocol unifies the basic Chipmunk types as well as making it easy to create custom composite collections of the basic types. Additionally, the wrapper adds many convenience methods for doing common setup tasks as well as helper methods that integrate it with the rest of the Cocoa Touch API. The wrapper tries to do things the Objective-C way, adding useful method variations where it makes sense to do so.</p>

<p>You can find out more information on <a href="http://chipmunk-physics.net">Chipmunk's website</a>. While Objective-Chipmunk is not free like Chipmunk is, the enhanced API will almost certainly save you time and money. You'll also be helping to support further Chipmunk development!</p>

<h1>Let's get started!</h1>

<p>At the end of Ray's tutorial, you can load a map created in Tiled. Your player can move around, but he snaps to individual tiles, so the game doesn't feel very smooth. First, take a look at the interface for our class. It hasn't changed much from the previous tutorial.</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; "><span style="color:#236e25;">// HelloWorldLayer<br />
</span><span style="color:#881350;">@interface</span> HelloWorldLayer : CCLayer<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Inside the HelloWorld class declaration<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;CCTMXTiledMap *_tileMap;<br />
&nbsp;&nbsp;&nbsp;&nbsp;CCTMXLayer *_background;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;CCTMXLayer *_meta;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;CCPhysicsSprite *_player;<br />
}</div>

<p>
The CCTMX classes are used for reading the tile map. Remember, the <code>_background</code> layer contains the tile artwork, such as the desert, the cacti, the roads, and the walls. The  <code>_meta</code> layer contains <A HREF="http://www.raywenderlich.com/1186/collisions-and-collectables-how-to-make-a-tile-based-game-with-cocos2d-part-2">hand-painted collision information</A>. Of course, there are other approaches that might work better in your game, but we're going to roll with this approach.
</p>
<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">CCPhysicsSprite *_player</div>
<p>CCPhysicsSprite is a new class in Cocos2d 2.1. Developers often struggle with making their graphics line up with a physics simulation, and this class is very helpful in that regard. Each time the physics simulation updates the position or rotation of an object in the world, the sprite is updated to reflect that. It is a subclass of CCSprite; if you are familiar with that class, the use is similar.</p>

<h2>Starting with init:</h2>

<p>I'll move quickly through this review:</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; "><span style="color:#236e25;">// on &quot;init&quot; you need to initialize your instance<br />
</span>-(<span style="color:#881350;">id</span>) <span style="color:#6c0540;">init</span><br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// always call &quot;super&quot; init<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Apple recommends to re-assign &quot;self&quot; with the &quot;super&quot; return value<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">if</span>( (<span style="color:#881350;">self</span>=[<span style="color:#881350;">super</span> <span style="color:#6c0540;">init</span>])) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Setup the space. We won't set a gravity vector since this is top-down<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;space = [[ChipmunkSpace <span style="color:#ff0000;">alloc</span>] <span style="color:#6c0540;">init</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isTouching = false;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">self</span>.touchEnabled = <span style="color:#881350;">YES</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tileMap = [CCTMXTiledMap <span style="color:#6c0540;">tiledMapWithTMXFile:</span><span style="color:#760f15;">@&quot;TileMap.tmx&quot;</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_background = [_tileMap <span style="color:#6c0540;">layerNamed:</span><span style="color:#760f15;">@&quot;Background&quot;</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">addChild:</span>_tileMap <span style="color:#6c0540;">z:</span>-<span style="color:#0000ff;">1</span>];<br />
</div>

<p>Basic setup of this Cocos2d layer includes stuff like enabling touches, loading the tilemap, and adding it to the layer. Confused? Check <A href="http://www.raywenderlich.com/1163/how-to-make-a-tile-based-game-with-cocos2d">this tutorial</A>.
</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCTMXObjectGroup *objects = [_tileMap <span style="color:#6c0540;">objectGroupNamed:</span><span style="color:#760f15;">@&quot;Objects&quot;</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#400080;">NSAssert</span>(objects != <span style="color:#881350;">nil</span>, <span style="color:#760f15;">@&quot;'Objects' object group not found&quot;</span>);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#400080;">NSMutableDictionary</span> *spawnPoint = [objects <span style="color:#6c0540;">objectNamed:</span><span style="color:#760f15;">@&quot;SpawnPoint&quot;</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#400080;">NSAssert</span>(spawnPoint != <span style="color:#881350;">nil</span>, <span style="color:#760f15;">@&quot;SpawnPoint object not found&quot;</span>);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">int</span> x = [[spawnPoint <span style="color:#6c0540;">valueForKey:</span><span style="color:#760f15;">@&quot;x&quot;</span>] <span style="color:#6c0540;">intValue</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">int</span> y = [[spawnPoint <span style="color:#6c0540;">valueForKey:</span><span style="color:#760f15;">@&quot;y&quot;</span>] <span style="color:#6c0540;">intValue</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_meta = [_tileMap <span style="color:#6c0540;">layerNamed:</span><span style="color:#760f15;">@&quot;Meta&quot;</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_meta.visible = <span style="color:#881350;">NO</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
</div>

<p>
Tiled supports annotating the map with specific information. So we've done so with a "SpawnPoint" object. We pull out the x and y values for use later. Meta is the name of a layer that controls collision information.  Tiles painted in this layer will be solid for our collisions.
</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// Add a CCPhysicsDebugNode to draw the space.<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCPhysicsDebugNode *debugNode = [CCPhysicsDebugNode <span style="color:#6c0540;">debugNodeForChipmunkSpace:</span>space];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">addChild:</span>debugNode];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
</div>

<p>
One nice thing about working with Chipmunk in Cocos2d is easy debugging of shapes with <code>CCPhysicsDebugNode</code>. This node draws all the objects in your physics space to the scene. So if you've got graphics that don't line up with your simulation, or you've forgotten to place a wall, you can easily determine what is going on. These two lines add that debug drawing.
</p>
<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// We've broken out the creation of the player and terrain into separate methods<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">createPlayer:</span>y <span style="color:#6c0540;">x:</span>x];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">createTerrainGeometry</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// add some crates, it's not a video game without crates!<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">for</span>(<span style="color:#881350;">int</span> i=<span style="color:#0000ff;">0</span>; i&lt;<span style="color:#0000ff;">16</span>; i++){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">float</span> dist = <span style="color:#0000ff;">50.0f</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">makeBoxAtX:</span> x + (i % <span style="color:#0000ff;">4</span>) * dist + <span style="color:#0000ff;">200</span> <span style="color:#6c0540;">y:</span> y + ( i / <span style="color:#0000ff;">4</span>) * dist - <span style="color:#0000ff;">200</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">setViewpointCenter:</span>_player.position];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// schedule updates, which also steps the physics space:<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">scheduleUpdate</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
</div>
<p>
And we do three things here. We create the player, then we create the terrain geometry, then add some boxes. After that there's a little cleanup by making sure the view starts centered on the player and that the Cocos2d update method is scheduled to be called. Let's look at each of these individually.
</p>

<h2>Creating a Top Down Player using Chipmunk:</h2>
<p>
Our goal is to have a player that smoothly moves through the world, slides along walls without gettings stuck, and can push around blocks. From the perspective of controls, we also want them to quickly and smoothly start and stop moving. So let's get to the code!
</p>

<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">- (<span style="color:#881350;">void</span>)<span style="color:#6c0540;">createPlayer:</span>(<span style="color:#881350;">int</span>)y <span style="color:#6c0540;">x:</span>(<span style="color:#881350;">int</span>)x<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#236e25;">// set up the player body and shape<br />
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">float</span> playerMass = <span style="color:#0000ff;">1.0f</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#881350;">float</span> playerRadius = <span style="color:#0000ff;">13.0f</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;playerBody = [space <span style="color:#6c0540;">add:</span>[ChipmunkBody <span style="color:#6c0540;">bodyWithMass:</span>playerMass <span style="color:#6c0540;">andMoment:</span>INFINITY]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;_player = [CCPhysicsSprite <span style="color:#6c0540;">spriteWithFile:</span><span style="color:#760f15;">@&quot;chipmunkMan.png&quot;</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;_player.chipmunkBody = playerBody;<br />
&nbsp;&nbsp;&nbsp;&nbsp;playerBody.pos = <span style="color:#003369;">ccp</span>(x,y);<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="color:#881350;">self</span> <span style="color:#6c0540;">addChild:</span>_player];</div>

<p>
First, we set up the ChipmunkBody for the player. We create it with a mass of 1.0 and an infinite moment of inertia. That infinite moment will prevent the player from rotating. A player that could rotate would start spinning when you slide against walls. And when a rotating player came in contact with something they could push, like a box, the friction between the player and the box would cause it to move in a weird way.
</p>
<p>
_player is our CCSprite- in this case, a CCPhysicsSprite. CCPhysicsSprite is a subclass of CCSprite that ties the sprite to a physics body. When the physics body moves around, the sprite also moves- in fact what happens behind the scene is that the sprite just accesses the physics body for position, rotation, etc. We set the body of the physics sprite to the ChipmunkBody we just made, and then set the position to (x, y), the position of the spawn point we passed in as an argument. 
</p>
<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;ChipmunkShape *playerShape = [space <span style="color:#6c0540;">add:</span>[ChipmunkCircleShape <span style="color:#6c0540;">circleWithBody:</span>playerBody <span style="color:#6c0540;">radius:</span>playerRadius <span style="color:#6c0540;">offset:</span>cpvzero]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;playerShape.friction = <span style="color:#0000ff;">0.1</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;</div>
<p>
Circles make good representations of just about any character. Before you think you need a more complicated polygon, please start with a circle- there are several advantages. Most importantly, circles have no edges or corners that get caught on other geometry. Since they have a constant radius, you are always sure of the size of the player and what they can fit into. We set a little friction, mostly to dictate how our player interacts with other objects.
</p>
<p>
Although we're thinking of this as a top-down game, the friction component does not represent the player's friction with the ground. There isn't a 'ground' object in our game- you're just always in contact with the ground. We'll get to this more later.
</p>


<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;targetPointBody = [[ChipmunkBody <span style="color:#ff0000;">alloc</span>] <span style="color:#6c0540;">initStaticBody</span>];<br />
&nbsp;&nbsp;&nbsp;&nbsp;targetPointBody.pos = <span style="color:#003369;">ccp</span>(x,y); <span style="color:#236e25;">// make the player's target destination start at the same place the player.<br />
</span></div>
<p>
We use a static body as a control body. This control body represents the target destination of the player. Because this is an iOS demo, we decided to go with a control scheme where you tap a point on the screen, and the character moves towards it. If you hold down your finger, the player keeps moving in that direction. So when it's time to handle input, it's very simple, we just set the position of the control body to the touch.
</p>
<p>
But how does this work?
</p>
<div style="text-align:left;color:#000000; background-color:#ffffff; border:solid black 1px; padding:0.5em 1em 0.5em 1em; overflow:auto;font-size:small; font-family:monospace; ">&nbsp;&nbsp;&nbsp;&nbsp;ChipmunkPivotJoint* joint = [space <span style="color:#6c0540;">add:</span>[ChipmunkPivotJoint <span style="color:#6c0540;">pivotJointWithBodyA:</span>targetPointBody <span style="color:#6c0540;">bodyB:</span>playerBody <span style="color:#6c0540;">anchr1:</span>cpvzero <span style="color:#6c0540;">anchr2:</span>cpvzero]];<br />
&nbsp;&nbsp;&nbsp;&nbsp;joint.maxBias = <span style="color:#0000ff;">200.0f</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;joint.maxForce = <span style="color:#0000ff;">3000.0f</span>;</div>
<p>
Joints control the motion of the player. Our pivot joint pulls the player towards the targetPointBody. Because that's a static body, only the player moves (unless we explicitly set the position of targetPointBody). It sort of acts like a spring or a rubber band, with the player constantly trying to move towards the control point, but it's simpler than that. There's no springy-ness to the motion- we have just two values to tweak:
</p>
<p>
<stong>maxBias</strong> controls the maximum speed at which a joint can be corrected. So if our playerBody is far away from the targetPointBody, there's a limit to how far per second the player is pulled towards the targetPointBody. So this is really a max speed for the player's motion across the world. This works great for our game since we want the player to move at the same speed if he's going horizontally, vertically, or diagonally.
</p>
<p>
<stong>maxForce</strong> controls the maximum force the joint will apply to correct the positions. If you've ever seen things <A href="http://www.youtube.com/watch?v=vfl33Tn0pYc">explode in video games</A> (I'm sure you've seen a thousand of them), you'll know why you want to set maximum forces. Often these glitches are a result of something exerting huuuuuuuge amounts of force trying to get something to move. By adjusting this maxForce value, you control things like how many boxes we're able to push. 
</p>
<p>
<em>But why not just set the position of the player body when I want to move him?</em>  Good question! Think of setting the position of a body to be "teleporting" that object somewhere. You aren't telling the physics engine how it got there. Chipmunk doesn't know how much force should be applied if it does hit an object along the way. And you may have teleported something right into a wall. Chipmunk will still resolve that collision and fix it, but you'll see the object you've teleported move into the wall more than you would have otherwise. 
</p>
<em>Well then, how about just setting the velocity each frame?</em>  This is an improvement! By setting the velocity, the physics engine solver can set the position and does a better job of ensuring the object doesn't move into another piece of geometry. When you have a collision, the engine knows the speed of the colliding objects and can calculate how they get knocked back.</p>
<p>
Follow along with me. Place our hand on a wall... then apply a velocity to it- into the wall. You can't. You can apply a force. (Hopefully your personal maxForce is not enough to move your wall.. otherwise, I'm sorry for broke your wall). So you could apply forces instead. That works great for things like cannons, but continual forces can be awkward when you've got a character that you want to maintain moving at a constant speed.
</p>
<p>
And finally, by using a control point and a joint, we don't have to worry calculating if we're close to our destination point and adjusting the force or velocity. We also get to slide around edges of walls. Pretty slick for just a few lines of code!
</p>


<h2>Creating the terrain geometry using Chipmunk's Autogeometry features:</h2>
<p>

</p>

	</body>
</html>
